# Клиент-серверное приложение

Для запуска приложения ознакомтесь с инструкцией.

**Запуск тестов описан в разделе `Автотесты`**
 
# Серверная часть

1. Установить nodejs `v12.16.2`.

2. В проекте лежит шаблон `.env-template`, его нужно скопировать, переименовать
   в `.env` и прописать значения переменных.

Где,

- `AUTH_TOKEN` - токен для работы с api;
- `WORKSPACES` - путь к папке, где лежат все склонированные репозитории;
- `TMP` - путь к папке, где хранится кэш логов;
- `PORT` - порт на котором поднимается приложение.

3. Через терминал:

- Перейти в папку с сервером `cd server`;
- Установить зависимости через `npm install`.

## Доступные команды

- `npm start` - запуск приложения
- `npm nodemon` - запуск приложения в режиме автоматического перезапуска сервера
  каждый раз после внесения измений в код
- `npm test` - unit-тесты на код

## API

Разработано REST API для работы клиентской части приложения:

- `GET /api/settings` - получение сохраненных настроек репозитория;
- `POST /api/settings` - сохранение настроек;
- `GET /api/builds` - получение списка сборок, которые стоят в очереди на
  выполнение;
- `POST /api/builds/:commitHash` - добавление сборки в очередь на выполнение;
- `GET /api/builds/:buildId` - получение информации о конкретной сборке по
  uid-сборки;
- `GET /api/builds/:buildId/logs` - получение логов завершенной сборки.

## Особенности реализации

- При выполнении запроса `POST /api/settings` клонируется репозиторий. Операция
клонирования репозитория переделал на синхронную. Форма сохранения будет недоступна
до тех пор, пока репозиторий не склонируется полностью.

- При сохранении настроек через `POST /api/settings` добавил кэширование
  названия репозитория, чтобы при повторной отправки запроса не клонировать
  репозиторий еще раз.

Алгоритм такой:

- Проверяем, есть ли в кэше репозиторий;
- Если нет, то клонируем;
- Иначе ничего не делаем.

Участок кода при клонировании репозитория:

```javascript
if (!isRepo(repoName)) {
  await gitClone(process.env.WORKSPACES, repoName);
}
```

- При выполнении `GET /api/builds/:buildId/logs` лог кэшируются. В json
  кэшируется только uid лога, а сам лог хранится в файле. JSON - это
  структурированные данные, у меня не получилось работать с ним через потоки.
  Поэтому, я решил, что из кэша буду получать только uid-файла с логом, а сам
  лог уже перенаправлю на клиент через потоки. Таким способом решил избавиться
  от возможных проблем с переполнением памяти.

- Информация о `commitHash` извлекается командой

 `git log -1 --pretty=format:{"authorName":"%cn", "commitMessage":"%s", "branchName":"master" }' hash`,
  пока зашил master в branchName. Планирую написать метод, в котором отдельно
  буду доставать имя ветки. Командой git log получить название нельзя.

- Есть метод,
  
  ```
   const parseRepoName = (fullname) => {
     const arr = fullname.split('/');
     const len = arr.length;
     return parse(arr[len - 1]).name;
   };
  
  ```
  который парсит строку и вытаскивает название корневой папки репозитория. Метод
  может работать нестабильно, например, из-за отстутствия валидации названия
  репозитория на клиенте. Подразумевается, что валидация на клиенте будет.

## Технологии

- `lowdb` - библиотека с удобным api для работы с json (использовал для работы с
  кэшем);
- `axios` - библиотека для выполнения http-запросов;
- `dotenv` - утилита для задания переменных окружения в файле `.env`;
- `express` - фреймворк для web-приложений.

# Клиентская часть

## Преднастройка до запуска приложения

1. В файле `axios.js` необходимо в поле `baseURL` указать корректный url адрес к
   серверу.

2. Через терминал:

- Перейти в папку с клиентом `cd client`;
- Установить зависимости через `npm install --python=python3.7`;
- Поднять приложение через `npm run start`.

## Доступные команды

- `npm run start` - запускает приложение;
- `npm run build` - команда собирает проект в папку `build`;
- `npm run test` - запуск интеграционных тестов.

# Автотесты

Написаны автотесты на клиенте и сервере.
Предварительно разбил систему на логические блоки.

Серверная часть:
* Роутинг запросов;
* Работа с гитом;
* Работа с кэшем;
* Работа с api-внешнего сервиса (предпологаем, что разработчики сервиса
провели тестирование api).

Клиентская часть:
* Работа с состоянием компонентов (state компонента, общее хранилище состояний redux);
* Работа с side effects (запросы к api-внешнего сервиса, sagas);
* Интерфейс (отображение компонентов, валидация форм, редиректы, клики).

## Модульные

В силу ограничения по времени, модульными автотестами покрыта только
серверная часть приложения - логический блок роутинг.

Для запуска необходимо:

1. Перейти в папку - `cd server/test`;
2. Запустить тесты - `npm run test`.

Покрыты ручки:

* GET api/settings
* POST api/settings
* GET api/builds
* POST /api/builds/:commitHash
* GET /api/builds/:buildId

api-внешнего сервиса замокано с помощью библиотеки `axios-mock-adapter`.
Утилитарные методы для работы с гитом обернуты в stub библиотеки `sinon.js`.

Сейчас тестируется только корректная работа роута, без логики утилитарных методов.
Для полноценного покрытия еще нужно покрыть утилитарные методы. Их пока не успел
дописать, в процессе.
 
## Интеграционные
В силу ограничения по времени интеграционными тестами покрыта только часть
функционала - редирект, форма валидации.

Для запуска необходимо:

1. Перейти в папку - `cd /client`;
1. Поднять standalone server selenium;
2. Запустить тесты `npm run test`.

# TODO

Замечания, которые остались и планируются дорабатываться:

- Заменить стандартную иконку в полях ввода на иконку из макета;
- Удалить избыточные компоненты;
- Ввести bem-naming для React;
- Уменьшить уровень вложенности в контентных блоках;
- Исправить баги в верстке, доработать адаптивность;
- Вынести в утилитарный файл общие селекторы;
- Добавить scroll в history;
- Придумать нормальную композицию компонентов (либо затащить композицию
  bem-react-core при переносе на типизацию);
- Вынести повторяющийся код в утилитарные файл;
- Разбить компоненты на базовые и контентные;
- Добавить ssr;
- Исправить переход на карточку билда по /url
- Поправить баги при сохранении формы Run Build
- Объединить package.json клиента и сервера
