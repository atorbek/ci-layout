# Типизация

Перевод JavaScript на TypeScript.

## Запуск CI
- Поднять сервер - [инструкция](server/README.md)
- Поднять клиента - [инструкция](client/README.md)

## Мотивация
Несмотря на сложность перевода решил слить изменения с ts в основную ветку.
- Полный контроль типов, создается чувство уверенности корректного определения
типов js в runtime;
- Отлавливание багов связанными с типизацией на самом раннем этапе.

## Сложность перевода
- Первое знакомство;
- В пред. ДЗ затащил библиотеки react-saga, redux-form, которые
создали определенную боль при переводе. Пришлось неплохо покапаться в тайпингах и
хорошенько погуглить:);
- yield в saga не умеет возвращать тип асинхронного запроса. Потратил время сначала
на осознание, затем на поиск решения;
- В redux-form намучался с типами экшенов формы;
- В пред. ДЗ перемудрил с кол-вом компонентов и их вложенностью. Добавило рутины при переводе;

## Найденные баги
Не работал loader в истории билдов, проблема была в типе переменной. С Указанием типа
ошибка всплыла на поверхность.

## TODO
- Перевести тесты на ts (функциональные, модульные);
- Заменить any (2 шт.) на конктретный тип;
- Перевести оставшиеся компоненты на ts (самое сложное сделано, перевести по аналогии).

# Инфраструктура

 - Билд-агент - [Readme.md](build-agent/README.md)
 - Билд-сервер - [Readme.md](build-server/README.md)
 
**Требования**
 
**_Сервер должен максимально утилизировать имеющихся агентов_**

Алгоритм

 * Билд-сервер с интервалом проверяет очередь билдов;
 * Находит билды в статусе Waiting;
 * Смотрит список зарегистрированных агентов;
 * Находит свободные агенты и ставит задачу на выполнение;
 * Если есть задача, но нет свободных агентов, ждет,
 когда агент освободится.
 
 Т.о билд-агенты не простаивают.
 
 Из особенностей: сервер проверяет первые 100 билдов в очереди на статус `Waiting`.
 Кол-во регулируется параметром в `agent-conf.json`. 
 
 Может возникнуть ситуация, когда в очереди 105 билдов в статусе `Waiting`,
 тогда первые 5 билдов не обработаются сервером. 

**Решить проблему** можно добавлением в api ручки для получения всех билдов в статусе `Waiting` 
либо ограничить очередь билдов на выполнение. 
 
**_Сервер должен корректно обрабатывать ситуацию, когда агент прекратил работать между сборками_**

Алгоритм
* Сервер пытается отправить запрос агенту n-раз;
* Если агент не ответил за n попыток, сервер отписывает агента;
* А билд перенаправляет на другой, свободный, агент.

**_Сервер должен корректно обрабатывать ситуацию, когда агент прекратил работать в процессе выполнения сборки_**

Алгоритм
* Сервер кэширует выполнение билда на агенте;
* Периодически проверяет кэш и находит занятые агены;
* Затем сравнивает с макс. таймаутом на выполнение билда;
* И если время выполнения превышает таймаут, отписывает агента, переводит билд в статус `Cancel`.

Если агент был отписан сервером, то считаем что с ним возникли проблемы и нужно,
в ручном режиме, проверить его работоспособность.

Понять, что агент отвалился, можно по отмененному билду в ci.

Может возникнуть ситуация, когда агент был отписан сервером,
но билд, просто, долго выполнялся, тогда агент отправит результаты прогона.
При отправке возникнет ошибка, потому что билд был отменен сервером. Текущий билд придется перепоставить в ci.
 
**_Агент должен корректно обрабатывать ситуацию, когда при старте не смог соединиться с сервером_**

Если агент не смог соединиться с сервером, он пытается повторить запрос n-раз.
Если n попыток не хватило, агент завершает процесс со статусом 1.

**_Агент должен корректно обрабатывать ситуацию, когда при отправке результатов сборки не смог соединиться с сервером_**

Агент пытается повторить запрос n-раз. Если n попыток не хватило, агент завершает отправку запроса.
Если проблема не в сервере, а сетевая, после прохождения таймаута времени выполнения сборки, сервер отпишет агента.

Как вариант, можно не ограничивать агент кол-вом попыток, тогда если проблема в сервере, то после починки
и возобновления работы, результаты сборки успешно отправятся в БД.

# CI

 - Cервер - [Readme.md](server/README.md)
 - Клиент - [Readme.md](client/README.md)

## Автотесты

Написаны автотесты на клиенте и сервере.
Предварительно разбил систему на логические блоки.

Серверная часть:
* Роутинг запросов;
* Работа с гитом;
* Работа с кэшем;
* Работа с api-внешнего сервиса (предпологаем, что разработчики сервиса
провели тестирование api).

Клиентская часть:
* Работа с состоянием компонентов (state компонента, общее хранилище состояний redux);
* Работа с side effects (запросы к api-внешнего сервиса, sagas);
* Интерфейс (отображение компонентов, валидация форм, редиректы, клики).

### Модульные

В силу ограничения по времени, модульными автотестами покрыта только
серверная часть приложения - логический блок роутинг.

Для запуска необходимо:

1. Перейти в папку - `cd server/test`;
2. Запустить тесты - `npm run test`.

Покрыты ручки:

* GET api/settings
* POST api/settings
* GET api/builds
* POST /api/builds/:commitHash
* GET /api/builds/:buildId

api-внешнего сервиса замокано с помощью библиотеки `axios-mock-adapter`.
Утилитарные методы для работы с гитом обернуты в stub библиотеки `sinon.js`.

Сейчас тестируется только корректная работа роута, без логики утилитарных методов.
Для полноценного покрытия еще нужно покрыть утилитарные методы. Их пока не успел
дописать( В процессе.
 
### Интеграционные
В силу ограничения по времени интеграционными тестами покрыта только часть
функционала - редирект, форма валидации.

Для запуска необходимо:

1. Перейти в папку - `cd /client`;
1. Поднять standalone server selenium;
2. Запустить тесты `npm run test`.

## TODO

Замечания, которые остались и планируются дорабатываться:

- Заменить стандартную иконку в полях ввода на иконку из макета;
- Удалить избыточные компоненты;
- Ввести bem-naming для React;
- Уменьшить уровень вложенности в контентных блоках;
- Исправить баги в верстке, доработать адаптивность;
- Вынести в утилитарный файл общие селекторы;
- Добавить scroll в history;
- Придумать нормальную композицию компонентов (либо затащить композицию
  bem-react-core при переносе на типизацию);
- Вынести повторяющийся код в утилитарные файл;
- Разбить компоненты на базовые и контентные;
- Добавить ssr;
- Исправить переход на карточку билда по /url
- Объединить package.json клиента и сервера
